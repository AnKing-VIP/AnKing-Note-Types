<%#

# Parameters
- selector: string

# Components
components/ankiPersistence

_%>

<!-- BEGIN WRAPPER CODE shuffle -->

<script>
    (() => {
        <%_ if (typeof selector !== "undefined") { _%>
        const selectors = [".shuffle", "<%- selector %>"];
        <%_ } else { _%>
        const selectors = [".shuffle"];
        <%_ } _%>
        const shuffleMap = Persistence.getItem("shuffle") || {};
        const shuffledWordClass = "shuffled-word";

        function isFront() {
            const hasHrMarker = document.querySelector("hr[id=answer]");
            const hasClozeFieldClass = document.querySelector(".clozefield");
            return !hasHrMarker && !hasClozeFieldClass;
        }

        function shuffle(array, indexMap) {
            let currentIndex = array.length;
            while (currentIndex != 0) {
                currentIndex--;
                let randomIndex = indexMap[currentIndex] !== undefined ? indexMap[currentIndex] : Math.floor(Math.random() * (currentIndex + 1));
                indexMap[currentIndex] = randomIndex;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex],
                    array[currentIndex],
                ];
            }
        }

        function shuffleElements(elements) {
            elements = elements.filter(e => !e.matches(".no-shuffle *"));
            if (elements.length === 0) {
                return;
            }
            const shuffledElements = Array.from(elements);
            // Assuming elements[0] is not also the first element in a different list to shuffle
            const mapKey = shuffledElements[0];
            const indexMap = shuffleMap[mapKey] || {};
            elements = elements.map(el => {
                const placeholder = document.createTextNode('');
                el.replaceWith(placeholder);
                return placeholder;
            });
            shuffle(shuffledElements, indexMap);
            shuffleMap[mapKey] = indexMap;
            for (let i = 0; i < elements.length; i++) {
                elements[i].replaceWith(shuffledElements[i]);
            }
        }

        function shuffleList(listElement) {
            const items = Array.from(listElement.querySelectorAll("li"));
            shuffleElements(items);
        }

        /**
         * Shuffle words connected by "and" or "or".
         * e.g. "fluoroquinolones, macrolides, and ketoconazole"
         **/
        function shuffleSentences(element) {
            const innerHTML = element.innerHTML;

            const connectorMatch = innerHTML.match(/\s+(and|or)\s+([^,]+)$/i);
            if (!connectorMatch) {
                return;
            }

            const connector = connectorMatch[1];
            const lastItem = connectorMatch[2].trim();
            const beforeConnector = innerHTML.substring(0, innerHTML.lastIndexOf(connectorMatch[0]));
            const items = [];
            let currentItem = '';
            let tagDepth = 0;
            let inTag = false;

            for (let i = 0; i < beforeConnector.length; i++) {
                const char = beforeConnector[i];

                if (char === '<') {
                    inTag = true;
                    if (beforeConnector[i + 1] !== '/') {
                        tagDepth++;
                    } else {
                        tagDepth--;
                    }
                } else if (char === '>') {
                    inTag = false;
                }

                if (char === ',' && !inTag && tagDepth === 0) {
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    currentItem = '';
                } else {
                    currentItem += char;
                }
            }

            if (currentItem.trim()) {
                items.push(currentItem.trim());
            }

            items.push(lastItem);

            if (items.length < 2) {
                return;
            }

            const cleanedItems = items.map(item => {
                return item.replace(/,\s*(?=<\/|$)/g, '');
            });

            const indexMap = shuffleMap[element] || {};

            const itemsToShuffle = [...cleanedItems];
            shuffle(itemsToShuffle, indexMap);
            shuffleMap[element] = indexMap;

            let newHTML;
            if (itemsToShuffle.length === 2) {
                newHTML = `${itemsToShuffle[0]} ${connector} ${itemsToShuffle[1]}`;
            } else {
                const allButLast = itemsToShuffle.slice(0, -1);
                const last = itemsToShuffle[itemsToShuffle.length - 1];
                newHTML = `${allButLast.join(', ')}, ${connector} ${last}`;
            }

            element.innerHTML = newHTML;
        }

        for (const selector of selectors) {
            for (const container of document.querySelectorAll(selector)) {
                if (["UL", "OL"].includes(container.tagName)) {
                    shuffleList(container);
                }
                for (const parentElement of container.querySelectorAll(
                    "ol, ul"
                )) {
                    shuffleList(parentElement);
                }
                const images = Array.from(container.querySelectorAll("img"));
                shuffleElements(images);
            }
        }
        for (const element of document.querySelectorAll(".shuffle-sentence")) {
            shuffleSentences(element);
        }

        if (isFront()) {
            Persistence.setItem("shuffle", shuffleMap);
        } else {
            Persistence.removeItem("shuffle");
        }
    })();
</script>

<!-- END WRAPPER CODE -->
